//modifiyed by akira_you
//original is : https://github.com/stereolabs/zed-examples/tree/master/spatial%20mapping
///////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2017, STEREOLABS.
//
// All rights reserved.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
///////////////////////////////////////////////////////////////////////////






#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <vector> 
#include <GL/glew.h>
#include "GL/freeglut.h"
#include <sl/Camera.hpp>

#include "GLObject.hpp" // Utils to use GLSL Shader and mesh
#include "utils.hpp"
#include "cuda_gl_interop.h"


/// ZED object (camera, mesh, pose)
sl::Camera zed_; //handle to ZED Camera
sl::Mat left_image; //sl::Mat to handle a image on gpu
sl::Pose pose_; //sl::Pose to handle the position of the ZED in world space
sl::Mesh mesh_; //sl::Mesh to handle the mesh generated by the spatial mapping 
std::vector< sl::Translation > tlog_;

sl::SpatialMappingParameters spatial_mapping_params;
sl::MeshFilterParameters filter_params;
sl::TRACKING_STATE tracking_state;

// For CUDA-OpenGL interoperability
cudaGraphicsResource* pcuImageRes; //cuda GL resource

// Opengl mesh container
MeshObject* mesh_object = NULL;
sl::float3 mesh_color; //defines the color of the mesh

// Opengl object
Shader* shader_mesh = NULL; //GLSL Shader for mesh
Shader* shader_image = NULL; //GLSL Shader for image
GLuint zed_window; //window ID
GLuint imageTex; //OpenGL texture mapped with a cuda array (opengl gpu interop)
GLuint shMVPMatrixLoc_; //Shader variable loc
GLuint shColorLoc_; //Shader variable loc
GLuint texID; //Shader variable loc (sampler/texture)
GLuint fbo = 0; //FBO
GLuint renderedTexture = 0; //Render Texture for FBO
GLuint quad_vb; //buffer for vertices/coords for image

// OpenGL camera projection matrix (inside a sl::Transform)
sl::Transform camera_projection;

// OpenGL Viewport size
static const int wWnd = 1280;
static const int hWnd = 720;

// Spatial Mapping status
bool mapping_is_started = false;
bool tlog_is_started = false; //tracking log for make cource
// Utils
int grab_count;

//// Sample functions
void close();
void run();

void startMapping();
void stopMapping();
void startTlog();
void stopTlog();

void keyPressedCallback(unsigned char c, int x, int y);
void generateQuadGL();
int initGL();
void drawGL();
void printGL(float x, float y, char *string);
void printHelp();
sl::Transform rot_for_gl; //rotate matrix for OpenGL vs ROS
    

int main(int argc, char** argv) {
  rot_for_gl.setZeros();
  rot_for_gl.r00=1;
  rot_for_gl.r12=1;
  rot_for_gl.r21=-1;
  rot_for_gl.m31=1;
  
  // Init GLUT window
  glutInit(&argc, argv);
  glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);
  glutInitWindowSize(wWnd, hWnd);
  glutCreateWindow("ZED Spatial Mapping");

  // Setup configuration parameters for the ZED    
  sl::InitParameters parameters;

  if (argc > 1) parameters.svo_input_filename = argv[1];
  parameters.depth_mode = sl::DEPTH_MODE_QUALITY; // :DEPTH_MODE_PERFORMANCE | DEPTH_MODE_MEDIUM |DEPTH_MODE_QUALITY
  parameters.coordinate_units = sl::UNIT_METER; //ROS unit system
  parameters.coordinate_system = sl::COORDINATE_SYSTEM_RIGHT_HANDED_Z_UP; // ROS coordinates system

  // Open the ZED
  sl::ERROR_CODE err = zed_.open(parameters);
  if (err != sl::ERROR_CODE::SUCCESS) {
    std::cout << sl::errorCode2str(err) << std::endl;
    zed_.close();
    return -1;
  }

  // Configure Spatial Mapping and filtering parameters
  spatial_mapping_params.range_meter.second = sl::SpatialMappingParameters::get(sl::SpatialMappingParameters::RANGE_FAR);
  spatial_mapping_params.resolution_meter = sl::SpatialMappingParameters::get(sl::SpatialMappingParameters::RESOLUTION_LOW);
  spatial_mapping_params.save_texture =true;
  filter_params.set(sl::MeshFilterParameters::FILTER_LOW);
  spatial_mapping_params.max_memory_usage=6*1024;
  // Initialize OpenGL
  int res = initGL();
  if (res != 0) {
    std::cout << "Failed to initialize OpenGL" << std::endl;
    zed_.close();
    return -1;
  }

  printHelp();
  {
    // Enable tracking and spatial mapping.
    // Note: spatial mapping needs the motion tracking to operate. Don't forget to enable it as well.
    sl::TrackingParameters tracking_params;
    if(getenv("AREA_FILE"))
      tracking_params.area_file_path = getenv("AREA_FILE");
    zed_.enableTracking(tracking_params);
  }
  // Create callback function for keyboard event and main loop (display).
  // Then, start the glut main loop.
  glutKeyboardFunc(keyPressedCallback); //callback to handle key events
  glutDisplayFunc(run); //main loop callback
  glutCloseFunc(close); //close callback
  glutMainLoop();
    
  return 0;
}

void startTlog()
{
  tlog_.clear();
  std::cout << "** Start Translation log of camera position" << std::endl;
  tlog_is_started = true;
}
#include<fstream>
void stopTlog()
{
  std::ofstream of("tlog.xyz");
  for(int i=0;i<tlog_.size();i++){
    of << tlog_[i](0)<<"\t"<< tlog_[i](1)<<"\t"<< tlog_[i](2)<<std::endl;
  }
}
void startMapping()
{
  // Create Mesh handler for sending the extracted mesh to OpenGL
  mesh_.clear();
  if (mesh_object) delete mesh_object;
  mesh_object = new MeshObject(sl::Translation(0, 0, 0), false);

  // Color of wireframe (soft blue)
  mesh_color.r = 0.35;
  mesh_color.g = 0.65;
  mesh_color.b = 0.85;

  zed_.enableSpatialMapping(spatial_mapping_params);

  // Launch the first request of the mesh. Other requests will be done when current mesh has been retrieved
  zed_.requestMeshAsync();
  mapping_is_started = true;

  // Console information
  std::cout << "** Spatial Mapping is started ... **" << std::endl;
  return;
}

/**
 * This function grabs the ZED data and draw the image with the projected mesh.
 * This function is called everytime the display needs to be refreshed (50 or 60Hz)
 **/
void run(){
  if (zed_.grab() == sl::SUCCESS){
    // Retrieve image in GPU and send it to OpenGL
    zed_.retrieveImage(left_image, sl::VIEW_LEFT, sl::MEM_GPU);

    // CUDA - OpenGL interop : copy the GPU buffer to a CUDA array mapped to the texture.
    cudaArray_t ArrIm;
    cudaGraphicsMapResources(1, &pcuImageRes, 0);
    cudaGraphicsSubResourceGetMappedArray(&ArrIm, pcuImageRes, 0, 0);
    cudaMemcpy2DToArray(ArrIm, 0, 0, left_image.getPtr<uchar>(sl::MEM_GPU), left_image.getStepBytes(sl::MEM_GPU), left_image.getWidth() * 4, left_image.getHeight(), cudaMemcpyDeviceToDevice);
    cudaGraphicsUnmapResources(1, &pcuImageRes, 0);

    // Get the pose data for future use (projection of the mesh in the current image)
    tracking_state = zed_.getPosition(pose_);
    if((tracking_state==sl::TRACKING_STATE_OK)&&(tlog_is_started)){
      tlog_.push_back(pose_.getTranslation());
    }
    // Spatial Mapping mesh request (only if Spatial Mapping is started)
    // Spatial Mapping is started/stopped when space bar is pressed (see keyPressedCallback())
    if (mapping_is_started) {
      // If mesh request status returns true, a new updated mesh is available. If not, then just do nothing : at next grab, we will check again.
      if (zed_.getMeshRequestStatusAsync()== sl::SUCCESS) {
	// Get the current mesh generated and send it to opengl
	if (zed_.retrieveMeshAsync(mesh_) == sl::SUCCESS)
	  mesh_object->updateMesh(mesh_);
	// Ask for a new update
	zed_.requestMeshAsync();
      }
    }
        
    ////// OpenGL draw call
    // Always draw the mesh even if not updated. Since the camera position changes every frame, the mesh needs to be projected on the image, using the very last camera position 
    drawGL();
  }

  // Check if we are reading an SVO file, and close the window and stop the mapping if we reached the end
  if ( zed_.getSVOPosition() > 0 && zed_.getSVOPosition() == zed_.getSVONumberOfFrames()) {
    glutLeaveMainLoop();
    if (mapping_is_started)
      stopMapping();
  }

  // Get ready for next update
  glutPostRedisplay();
}

void stopMapping(){

  // --> stop the mesh request and extract the whole mesh to filter it and save it as an obj file
  mapping_is_started = false;

  std::cout << "** Stop Spatial Mapping ... **" << std::endl;

  // Extract the whole mesh and filter it
  zed_.extractWholeMesh(mesh_);
  std::cout << ">> Mesh has been extracted..." << std::endl;

  // Filter the extracted mesh
  mesh_.filter(filter_params);
  std::cout << ">> Mesh has been filtered..." << std::endl;

  // If textures have been saved during spatial mapping, apply them to the mesh
  if (spatial_mapping_params.save_texture) {
    mesh_.applyTexture();
    std::cout << ">> Mesh has been textured..." << std::endl;
  }

  //Save as an OBJ file
  bool t = mesh_.save("mesh_gen.obj");
  if (t) std::cout << ">> Mesh has been saved under \"mesh_gen.obj\" filename" << std::endl;
  else std::cout << ">> Failed to save the mesh under \"mesh_gen.obj\" filename" << std::endl;

  // Disable the spatial mapping module since we don't need it anymore
  zed_.disableSpatialMapping();

  return;
}

/**
 *  This function close the sample (when a close event is generated)
 **/
void close() {
  left_image.free();

  if (shader_mesh) delete shader_mesh; //GLSL Shader for mesh
  if (shader_image) delete shader_image; //GLSL Shader for image
  if (mesh_object) delete mesh_object;
  zed_.disableTracking("now.area");

  zed_.close();
}

/**
 * Utils to generate quads for image texture
 **/
void generateQuadGL() {
  // The fullscreen quad's FBO
  static const GLfloat g_quad_vertex_buffer_data[] = {
    -1.0f, -1.0f, 0.0f,
    1.0f, -1.0f, 0.0f,
    -1.0f, 1.0f, 0.0f,
    -1.0f, 1.0f, 0.0f,
    1.0f, -1.0f, 0.0f,
    1.0f, 1.0f, 0.0f};

  //Generate a buffer to handle vertices for the GLSL shader.
  glGenBuffers(1, &quad_vb);
  glBindBuffer(GL_ARRAY_BUFFER, quad_vb);
  glBufferData(GL_ARRAY_BUFFER, sizeof(g_quad_vertex_buffer_data), g_quad_vertex_buffer_data, GL_STATIC_DRAW);
}

/**
 * This function initialize OpenGL window and objects
 **/
int initGL() {
  //Init glew after window has been created
  glewInit();
  glClearColor(0.0, 0.0, 0.0, 0.0); // When screen cleared, use black.

  // Get Image resolution (depending on InitParameter.camera_resolution or svo resolution)
  int w = zed_.getResolution().width;
  int h = zed_.getResolution().height;

  //Create and Register OpenGL Texture for Image (RGBA -- 4channels)
  glEnable(GL_TEXTURE_2D);
  glGenTextures(1, &imageTex);
  glBindTexture(GL_TEXTURE_2D, imageTex);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_BGRA_EXT, GL_UNSIGNED_BYTE, NULL);
  glBindTexture(GL_TEXTURE_2D, 0);
  cudaError_t err1 = cudaGraphicsGLRegisterImage(&pcuImageRes, imageTex, GL_TEXTURE_2D, cudaGraphicsMapFlagsNone);
  if (err1 != cudaError::cudaSuccess) return -1;

  //Create GLSL Shaders Mesh and Image
  shader_mesh = new Shader((GLchar*)MESH_VERTEX_SHADER, (GLchar*)MESH_FRAGMENT_SHADER);
  shMVPMatrixLoc_ = glGetUniformLocation(shader_mesh->getProgramId(), "u_mvpMatrix");
  shColorLoc_ = glGetUniformLocation(shader_mesh->getProgramId(), "u_color");
  shader_image = new Shader((GLchar*)IMAGE_VERTEX_SHADER, (GLchar*)IMAGE_FRAGMENT_SHADER);
  texID = glGetUniformLocation(shader_image->getProgramId(), "texImage");

  /////////////// Create Frame Buffer for offline rendering //////////////////
  // Here we render the composition of the image and the projection of the mesh on top of it in a texture (using FBO - Frame Buffer Object)
  //
  glGenFramebuffers(1, &fbo);
  glBindFramebuffer(GL_FRAMEBUFFER, fbo);

  // Generate a render texture (which will contain the image and mesh in wireframe overlay)
  glGenTextures(1, &renderedTexture);
  glBindTexture(GL_TEXTURE_2D, renderedTexture);

  // Give an empty image to OpenGL ( the last "0" as pointer )
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

  // Set "renderedTexture" as our color attachment #0
  glFramebufferTexture(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, renderedTexture, 0);

  // Set the list of draw buffers.
  GLenum DrawBuffers[1] = { GL_COLOR_ATTACHMENT0 };
  glDrawBuffers(1, DrawBuffers);

  // Always check that our framebuffer is ok
  if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {
    std::cout << "invalid FrameBuffer" << std::endl;
    return -1;
  }

  glBindFramebuffer(GL_FRAMEBUFFER, 0);

  ///////////// Create Projection Matrix for OpenGL. We will use this matrix in combination with the Pose (on REFERENCE_FRAME_WORLD) to project the mesh on the 2D Image.
  sl::CameraParameters camLeft = zed_.getCameraInformation().calibration_parameters.left_cam;
  camera_projection(0, 0) = 1.0f / tanf(camLeft.h_fov * M_PI / 180.f * 0.5f);
  camera_projection(1, 1) = 1.0f / tanf(camLeft.v_fov * M_PI / 180.f * 0.5f);
  float znear = 0.001;
  float zfar = 100.;
  camera_projection(2, 2) = -(zfar + znear) / (zfar - znear);
  camera_projection(2, 3) = -(2.f * zfar * znear) / (zfar - znear);
  camera_projection(3, 2) = -1;
  camera_projection(0, 2) = (camLeft.image_size.width - 2. * camLeft.cx) / camLeft.image_size.width;
  camera_projection(1, 2) = (-1.f * camLeft.image_size.height + 2. * camLeft.cy) / camLeft.image_size.height;
  camera_projection(3, 3) = 0;

  ////////////// Generate the Quad for showing the image in a full viewport
  generateQuadGL();

  return 0;
}

/**
 * This function draws a text with OpenGL
 **/
void printGL(float x, float y, char *string) {
  //set the position of the text in the window using the x and y coordinates
  glRasterPos2f(x, y);
  //get the length of the string to display
  int len = (int)strlen(string);
  //loop to display string
  for (int i = 0; i < len; i++) {
    glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, string[i]);
  }
}

/**
 * OpenGL draw function
 **/
void drawGL() {
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glEnable(GL_TEXTURE_2D);
  glActiveTexture(GL_TEXTURE0);

  glViewport(0, 0, wWnd, hWnd);

  ///// Render Image and wireframe mesh into a texture using the FrameBuffer
  //Bind the framebuffer and specify the viewport (full screen)
  glBindFramebuffer(GL_FRAMEBUFFER, fbo);

  ////////// Render the ZED view (Left) in the framebuffer
  glUseProgram(shader_image->getProgramId());
  glActiveTexture(GL_TEXTURE0);
  glBindTexture(GL_TEXTURE_2D, imageTex);
  glUniform1i(texID, 0);
  //invert y axis and color for this image (since its reverted from cuda array)
  glUniform1i(glGetUniformLocation(shader_image->getProgramId(), "revert"), 1);
  glUniform1i(glGetUniformLocation(shader_image->getProgramId(), "rgbflip"), 1);
	
  glEnableVertexAttribArray(0);
  glBindBuffer(GL_ARRAY_BUFFER, quad_vb);
  glVertexAttribPointer(
			0, // attribute 0
			3, // size
			GL_FLOAT, // type
			GL_FALSE, // normalized
			0, // stride
			(void*)0 // array buffer offset
			);

  glDrawArrays(GL_TRIANGLES, 0, 6); // 2*3 indices starting at 0 -> 2 triangles
  glDisableVertexAttribArray(0);
  glUseProgram(0);

  // if the Positional tracking is good, we can draw the mesh over the current image
  if (mesh_.triangles.size() && (tracking_state==sl::TRACKING_STATE_OK)) {
    glDisable(GL_TEXTURE_2D);
    // Send the projection and the Pose to the GLSL shader to make the projection of the 2D image.
    sl::Transform vpMatrix = sl::Transform::transpose(camera_projection *rot_for_gl* sl::Transform::inverse(pose_.pose_data));
    glUseProgram(shader_mesh->getProgramId());
    glLineWidth(1.0);
    glUniformMatrix4fv(shMVPMatrixLoc_, 1, GL_FALSE, vpMatrix.m);
    glUniform3fv(shColorLoc_, 1, mesh_color.v);
    // Draw the mesh in GL_TRIANGLES with a polygon mode in line (wire)
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
    mesh_object->draw(GL_TRIANGLES);
    glUseProgram(0);
  }
  //Draw tracking line
  if (tlog_.size() && (tracking_state==sl::TRACKING_STATE_OK)) {
    glColor3f(1.0, 1.0, 0.0);
    glLineWidth(3.0);
    glBegin(GL_LINE_STRIP);
    sl::Transform vpMatrix = camera_projection *rot_for_gl* sl::Transform::inverse(pose_.pose_data);
    sl::Transform tmp;
    tmp.setZeros();
    tmp.r00=1;
    tmp.r11=1;
    tmp.r22=1;
    tmp.m33=1; 
    for(int i=0;i<tlog_.size();i++){
      tmp.setTranslation(tlog_[i]);
      sl::Translation a=((sl::Transform)(vpMatrix*tmp)).getTranslation();
      glVertex3f(a(0),a(1),a(2));
    }
    glEnd();
    
  }

  // Unbind the framebuffer since the texture is now updated.
  glBindFramebuffer(GL_FRAMEBUFFER, 0);

  // Render the texture to the screen
  //Set back the polygon mode
  glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

  // Use the image shader to show it on the screen.
  glUseProgram(shader_image->getProgramId());
  glBindTexture(GL_TEXTURE_2D, renderedTexture);
  glUniform1i(texID, 0);
  glUniform1i(glGetUniformLocation(shader_image->getProgramId(), "revert"), 0);
  glUniform1i(glGetUniformLocation(shader_image->getProgramId(), "rgbflip"), 0);
  glEnableVertexAttribArray(0);
  glBindBuffer(GL_ARRAY_BUFFER, quad_vb);
  glVertexAttribPointer(
			0, // attribute 0
			3, // size
			GL_FLOAT, // type
			GL_FALSE, // normalized
			0, // stride
			(void*)0 // array buffer offset
			);
  // Draw the triangles
  glDrawArrays(GL_TRIANGLES, 0, 6);
  glDisableVertexAttribArray(0);
  glUseProgram(0);
  glDisable(GL_TEXTURE_2D);

  // show actions
  glColor4f(0.25f, 0.99f, 0.25f, 1.f);

  // show mapping state

  sl::SPATIAL_MAPPING_STATE state = zed_.getSpatialMappingState();
  if (state == sl::SPATIAL_MAPPING_STATE_OK || state == sl::SPATIAL_MAPPING_STATE_INITIALIZING) {
    glColor4f(0.25f, 0.99f, 0.25f, 1.f);
  } else if (state == sl::SPATIAL_MAPPING_STATE_NOT_ENABLED) {
    glColor4f(0.55f, 0.65f, 0.55f, 1.f);
  } else {
    glColor4f(0.95f, 0.25f, 0.25f, 1.f);
  }
  printGL(-0.99f, 0.90f, (char*)(std::string("** ") + sl::spatialMappingState2str(state)).c_str());
  printGL(-0.99f, 0.96f, (char*)(std::string("** ") + sl::trackingState2str(tracking_state)).c_str());

  // Increment count and swap buffers
  grab_count++;
  glutSwapBuffers();
}

/**
 * This function handles keyboard events (especially space bar to start the mapping)
 **/
void keyPressedCallback(unsigned char c, int x, int y) {
  switch (c) {
  case 's':
    if (!mapping_is_started)startMapping();
    break;
  case 't':
    if (!tlog_is_started)startTlog();
    break;
  case 'b':
    if (mapping_is_started)stopMapping();
    if (tlog_is_started)stopTlog();
    break;
  case 'q':
    if (mapping_is_started)stopMapping();
    if (tlog_is_started)stopTlog();
    
    std::cout << " 'q' has been pressed... Exit" << std::endl;
    glutLeaveMainLoop(); //this will call the close function	
    break;
  default:
    break;
  }
}

/**
 * This function displays help in console
 **/
void printHelp()
{
  std::cout << "*************************************************************" << std::endl;
  std::cout << "**   s -- start spatial mapping                            **" << std::endl;
  std::cout << "**   t -- start camera trajectory loging                   **" << std::endl;
  std::cout << "**   b -- stop 's' and 't'                                 **" << std::endl;
  std::cout << "**   q -- end this program                                 **" << std::endl;
  std::cout << "**                                                         **" << std::endl;
  std::cout << "**   output file                                           **" << std::endl;
  std::cout << "**   obj_mesh.obj and obj_mesh*.png: 3D mesh data of map   **" << std::endl;
  std::cout << "**   tlog.xyz: trajectory log                              **" << std::endl;
  std::cout << "**   now.area: area file for ZED SDK                       **" << std::endl;
  std::cout << "*************************************************************" << std::endl;
}
